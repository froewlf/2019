#### 1、什么是类加载？

* 类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后再堆区创建一个java.lang.Class对象，用来封装来在方法区的数据结构。
* 类的加载最终是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供访问方法区的数据机构的接口。

#### 2、类加载器

* 启动类加载器（Bootstarp ClassLoader），负责加载存放在JDK/jre/lib下，或被-Xbootclasspath参数指定路径的，并且能被虚拟机识别的类库。
* 扩展类加载器（Extension ClassLoader），该加载器有sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK/jre/bin/ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。
* 应用程序类加载器（Application ClassLoader），该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器。
* 自定义类加载器（contextClassLoader）
  * 为了解决父类加载器因为某些原因需要加载低层的类而创建的类加载器（上下文类加载器）

#### 3、什么场景下需要自定义类加载器？

* 加载特定路径的class文件
* 加载一个加密的网络文件
* 热部署加载class文件

#### 4、JVM加载class文件的过程（原理）？

* 当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备、解析）和初始化。
* 类的加载是把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不可用。
* 当类被加载后就进入链接阶段，这一阶段包含验证（确保被加载类能够满足java虚拟机的约束）、准备（为静态变量分配内存并设置默认的初始值）、解析（符合引用替换为直接引用）三个步骤。
* 最后JVM对类进行初始化。
  * 当虚拟机启动时，初始化用户指定的主类
  * 当遇到用以新建目标类实例的new指令时，初始化new指令的目标类
  * 当遇到调用静态方法指令、静态字段指令时，初始化该静态字段所在的类
  * 子类的初始化会触发父类的初始化
  * 如果一个接口定义了default方法，那么直接实现或间接实现该接口的类初始化，会触发该接口的初始化
  * 使用反射API对某个类进行反射调用时，初始化这个类
  * 当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。

#### 5、JVM内存分区

* 方法区（Method Area）
  * 方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
* 堆（Heap）
  * 是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有对象实例都在这里分配内存。
* 栈（Stacks）
  * PC寄存器（Program Counter Register）
    * 是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。
  * java方法栈
    * 与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同。java虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行时都会同时创建一个栈桢（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每个方法被调用直至执行完成的过程，就对应着一个栈桢在虚拟机栈中从入栈到出栈的过程。
  * 本地方法栈（Native Method Stacks）
    * 本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行java方法（也就是字节码）服务，而本地方法栈是为虚拟机使用到的Native方法服务的。

#### 6、什么是GC？为什么要有GC?

* GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动检测对象是否超过作用域从而达到自动回收内存的目的。

#### 7、都有哪些垃圾回收器？

* 新生代收集器
  * Serial收集器，单线程，采用标记复制算法
    * 缺点：单线程，在进行垃圾回收时会stop-the-world，内存使用效率低（复制算法）
    * 优点：不会造成大量的内存碎片（复制算法）
  * Parallel New收集器，就是Serial收集器的多线程版本，采用标记复制算法
    * 缺点：线程切换需要额外的开销，单CPU时效率不如Serial
    * 优点：不会造成大量的内存碎片（复制算法）
  * Parallel Scavenge收集器，类似Parallel New收集器，它更关注吞吐量，采用标记复制算法
* 老年代收集器
  * Serial Old收集器，单线程，采用标记压缩算法
  * Parallel Old收集器，Serial Old收集器的多线程版本，采用标记压缩算法
  * CMS收集器，并发收集器，采用标记清除算法
    * 初始标记
    * 并发标记
    * 重新标记
    * 并发清除
    * 并发重置
    * 缺点：
      * 对CPU资源非常敏感
      * 浮动垃圾（被标记后，不能被本次进行回收的垃圾）。需要设置CMS预留内存空间：“-XX:CMSInitiatingOccpancyFraction”，JDK1.5默认为68%，JDK1.6变大约为92%。
      * Concurrent Mode Failure
        * 如果CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样会导致另一次Full GC的产生。这样停顿时间就更长了，代价会更大，所以 "-XX:CMSInitiatingOccupancyFraction"不能设置得太大。
      * 产生大量内存碎片（标记清除算法）

* G1(garbage first)

  * G1是一个横跨新生代和老年代的垃圾收集器。G1已经打乱了前面所说的堆结构，直接将堆分成极其多的区域，每个区域都可以是Eden区、Survivor区或者老年代的一个。跟CMS收集器一样都能够在程序运行过程中并发的进行垃圾回收。采用标记-压缩算法。

  * G1能够针对每个细分的区域来进行垃圾回收。在选择进行垃圾回收的区域时，它会优先回收死亡对象较多的区域。这也是G1名字的由来。

  * 收回过程

    * 初始标记（stop the world）
    * 并发标记
    * 最终标记（stop the world）
    * 筛选回收（stop the world）

  * 优点

    * 停顿时间短
    * 可以指定最大的停顿时间
    * 不会产生内存碎片（标记-整理）

  * 缺点

    * G1需要维护记忆集（remembered set），维护记忆集的成本较高，带来了更高的执行负载，影响效率

  * 参数详情

    ![img](https://upload-images.jianshu.io/upload_images/2015574-07106dc0f17975a6.png?imageMogr2/auto-orient/strip|imageView2/2/w/974/format/webp)

* ZGC
  * 在JDK11中，加入了实验性质的ZGC。它的回收耗时平均不到2毫秒。是一款低停顿高并发的收集器。
  * ZGC几乎在所有地方并发执行的，除了初始标记是STW（stop the world）的。所以停顿时间几乎就损耗在初始标记上，这部分的实际是非常少的。那么其他阶段是怎么做到可以并发执行的呢？
    * ZGC主要新增了两项技术，
      * 着色指针Colored Pointer 
      * 读屏障 Load Barrier

#### 8、如何判断一个对象是存是亡？

* 引用计数法

  * 做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为0，则说明该对象已经死亡。
  * 存在循环引用的问题，导致其内存空间不可回收，从而造成内存泄漏。

* 可达性分析

  * 实质在于一系列GC Roots作为初始的存活对象集合（live set），然后从该集合出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。
  * GC Roots 
    * Java方法栈桢中的局部变量
    * 已加载类的静态变量
    * JNI handles
    * 已启动未停止的Java线程

  * 可达性分析，可以解决引用计数法中存在的循环引用问题。

#### 9、垃圾回收算法

* 标记 - 清除
* 标记 - 压缩
* 复制

#### 10、引用的分类

* 强引用：GC是不会被回收
* 软引用：描述有用但不是必须的对象，在发生内存溢出异常之前被回收
* 弱引用：描述有用但不是必须的对象，在下一次GC时被回收
* 虚引用（幽灵/幻影引用）：无法通过虚引用获得对象，用PhantomReference实现虚引用，虚引用用来在GC时返回一个通知。

#### 11、调优命令

* Sun JDK监控和故障处理命令有jps、jstat、jmap、jhat、jstack、jinfo
  * jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。
  * jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。
  * jmap，JVM Memory Map命令用于生成heap dump文件
  * jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看
  * jstack，用于生成java虚拟机当前时刻的线程快照。
  * jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。

#### 12、java内存模型

* ![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvOGY5ODMzMGRjOGFmNGNlOGNmNTM5N2EwMTMzMDhlYzI_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)

* 主内存和工作内存之间的交互

* 

* | 操作   | 作用对象 | 解释                                                         |
  | ------ | -------- | ------------------------------------------------------------ |
  | lock   | 主内存   | 把一个变量标识为一条线程独占的状态                           |
  | unlock | 主内存   | 把一个处于锁定状态的变量释放出来，释放后才可被其他线程锁定   |
  | read   | 主内存   | 把一个变量的值从主内存传输到线程工作内存中，以便load操作使用 |
  | load   | 工作内存 | 把read操作从主内存中得到的变量直接放入工作内存中             |
  | use    | 工作内存 | 把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量值的字节码指令时会执行这个操作 |
  | assing | 工作内存 | 把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作 |
  | store  | 工作内存 | 把工作内存中的一个变量的值传递到主内存中，一边writer操作     |
  | write  | 工作内存 | 把store操作从工作内存中得到的变量的值放入主内存的变量中      |

* 对于volatile变量的特殊规则

  * 可见性（Visibility）
    * 指当一个线程修改了共享变量的值，其他线程也能够立即得知这个通知。主要操作细节就是修改值后将值同步至主内存（volatile值使用前都会从主内存刷新）
  * 有序性
    * 禁止指令重排

* 对于long和double型变量的特殊规则

  * java要求对于主内存之间的八个操作都是原子性的，但是对于64位的数据类型，有一条宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read、和write这4个操作的原子性。这就是long和double的非原子性协定。

* happens-before原则

  * 这个原则是判断数据是否存在竞争、线程是否安全的主要依据。先行发生是Java内存模型中定义的两项操作之间的偏序关系。

  * 天然的先行发生关系

  * 

  * | 规则             | 解释                                                         |
    | ---------------- | ------------------------------------------------------------ |
    | 程序次序规则     | 在一个线程内，代码按照书写的控制流顺序执行                   |
    | 管程锁定规则     | 一个unlock操作先行发送与后面对同一个锁的lock操作             |
    | volatile变量规则 | volatile变量的写操作先行发生于后面对这个变量的读操作         |
    | 线程启动规则     | Thread对象的start()方法先行发生于此线程的每一个动作          |
    | 线程终止规则     | 线程中所有的操作都先行发生于对此线程的终止检测（通过Thread.join()方法结束、Thread.isAlive()的返回值检测） |
    | 对象终结规则     | 一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始 |
    | 传递性           | 如果操作A优先于操作B发生，操作B先于操作C发生，那么操作A先于操作C |
    |                  |                                                              |

#### 13、深拷贝和浅拷贝

* 浅拷贝：被复制的对象的所有的变量都与原对象有相同的值，而所有的引用对象仍然指向原来的对象。换言之，浅拷贝只是复制所拷贝的对象，不复制引用对象。
* 深拷贝：除了被复制对象的所有变量都有原来对象的值之外，还把引用也指向了被复制的新对象。

#### 14、finalize() 方法什么时候被调用？析构函数 (finalization) 的目的是什么？

* 调用时机：当垃圾回收器要宣告一个对象死亡时，至少要经过两次标记过程，如果对象在进行可达性分析后发现没有和GC Roots相连接的引用链，就会被第一次标记，并且判断是否执行finalizer()方法，如果对象覆盖finalizer()方法且未被虚拟机调用过，那么这个对象会被放置在F-Queue队列中，并在稍后由一个虚拟机自动建立的低优先级的Fianlizer线程区执行触发finalizer()方法，但不承诺等待其运行结束。
* finalization的目的：对象逃脱死亡的最后一次机会。比如你调用了一些native方法，要在finaliztion里取调用释放函数。

#### 15、双亲委派模型，它有什么好处？

* 某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。
* 使用双亲委派模型的好处在于Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类Java.long.Object，它存在在rt.jar中，无论哪一个类加载器要加载这个类，**最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载**，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个Java.long.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。因此，如果开发中尝试编写一个与rt.jar类库中重名的Java类，可以正常变量，但是永远无法被加载运行。

#### 16、什么情况下需要破坏双亲委派模型？

* 父类加载器需要加载下层的一些类的时候，例如使用ContextClassLoader（自定义类加载器）。这个类加载器可以通过java.long.Thread类的setContextClassLoader()方法进行设置，如果创建线程是还未设置，他将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用类加载器。

#### 17、JVM有哪些常用的启动参数

* -Xmx3559m：设置JVM**最大堆内存**为3550M
* -Xms3550m：设置JVM**初始堆内存**为3550M。此值可以设置为-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。
* -Xss128k：设置每个线程的栈大小。JDK5.0以后每个线程栈大小为1M，之前每个线程栈大小为256K。应当根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程的线程数还是有限制的，不能无限生成，经验值在3000-5000左右。需要注意的是：当这个值被设置的较大（例如>2MB）时将会在很大程度上降低系统的性能。
* -Xmn2g：设置**年轻代**大小为2G。在整个堆内存大小确定的情况下，增大年轻代将会减小年老代，反之亦然。此值关系到JVM垃圾回收，对系统性能影响较大，官方推荐配置为整个堆大小的3/8.
* -XX：NewSize=1024m：设置年轻代初始值为1024M
* -XX：MaxNewSize=1024m：设置年轻代最大值为1024M
* -XX：PermSize=256m：设置**持久代初始值**为256M
* -XX：MaxPermSize=256m：设置**持久代最大值**为256M
* -XX：NewRatio=4：设置年轻代（包括1个Eden和2个Survivor区）与年老代的比值。表示年轻代比年老代为1:4
* -XX：SurvivorRatio=4：设置**年轻代中Eden区与Survivor区的比值**。表示2个Sruvivor区与1个Eden区的比值为2:4，即1个Survivor区占整个年轻代大小的1/6。
* -XX：MaxTenuringThreshold=15：表示一个对象如果在Survivor区移动了15次还没有被垃圾回收就进入到年老代。

#### 18、说说自定义注解的场景及实现？

* 登录、权限拦截、日志处理、

* 注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。程序运行时，通过反射获取类中所有的属性和方法上的注解，这个注解是动态代理对象$Proxy1。通过代理对象电泳注解中自定义的方法，完成注解功能。

