#### 1、为什么说redis是单线程的？

* Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件处理器。它的组成机构分为4部分：多个Socket（套接字）、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以redis才叫单线程。
  * 什么是Reactor模式？
    * Reactor是基于NIO中实现多路复用的一种模式。
    * ![img](https://upload-images.jianshu.io/upload_images/13078107-0096aa4376530d03.png?imageMogr2/auto-orient/strip|imageView2/2/w/619/format/webp)
    * 同步的等待多个事件源到达（采用select()实现）
    * 将事件多路分解以及分配响应的事件服务进行处理，这个分派采用server集中处理（dispatch）
    * 分解的事件以及对应的事件服务应用从分派服务中分离出去（handler）
  * redis线程模型
  * ![img](https://upload-images.jianshu.io/upload_images/7368936-fe23b577eef07aa3.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)
  * IO多路复用程序监听多个Socket，将socket事件放入到一个先进先出的队列，文件事件分派器**单线程消费**队列中的事件，根据事件的不同再分派给不同的事件处理器。

* 单线程的redis足够快了，使用多线程麻烦。CPU不是redis的瓶颈，**内存**和**网络带宽**才是redis的瓶颈。
  * 内存：关系到redis存储的数据量
  * 网络带宽：
    * redis客户端执行一条命令分为4个过程：**发送命令**、**命令排队**、**命令执行**、**返回结果**。
    * 其中**发送命令**+**返回结果**，这一过程被称为**Round Trip Time（RTT，往返时间）**。
    * RTT，往返时间的耗时会影响redis的吞吐量。

#### 2、redis为什么快？

* 完全基于内存
* 单线程，避免了频繁的上下文切换
* 使用多路I/O复用模型，非阻塞IO
  * redis是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所有I/O操作在一般情况下往往不能直接返回，这会导致某一文件的I/O阻塞导致整个进程无法对其他客户提供服务，而I/O多路复用就是为了解决这个问题而出现的。
  * 多路I/O复用模型是利用select、poll、epoll可以同时监察多个流的I/O事件的能力，在空闲的时候会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞状态中唤醒，于是程序就会轮询一遍所有的流（epoll是只轮询那些真正发生了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。**这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程**。
  * redis的io模型主要是基于epoll实现的，不过他也提供了select和kqueue的实现，默认采用epoll。
    * epoll优点
      * epoll没有最大并发连接的限制，上限时最大可以打开文件的数目，这个数字一般远大于2048，一般来说这个数目和系统内存关系很大，具体数目可以cat/proc/sys/fs/file-max查看
      * 效率提升，Epoll最大的有点就在于它**只管“活跃”的连接**，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll
      * 内存拷贝，Epoll在这点上使用了**内存共享**，这个内存拷贝也省略了。

#### 3、redis持久化机制

* redis是一个支持持久化的内存数据库，通过持久化机制把内存中的数据同步到硬盘文件来保存数据持久化。当redis重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。
* 持久化机制实现：单独创建fork()一个子进程，将当前父进程的数据库复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，在用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。
* **RDB**是redis默认的持久化方式，安装一定的时间周期策略把内存的数据以快照的形式保存到硬盘二进制文件。即Snapshot快照存储，对应产生的数据文件为dump.rbd，通过胚子文件中的save参数来定义快照的周期。（快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品）

* **AOF**：Redis会将每一个收到的写命令都通过writer函数追加到文件最后，类似于MySQL的binlog。当Redis重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。
* 当两种方式同时开启时，数据恢复redis会优先选择AOF恢复。

#### 4、缓存穿透

* 缓存穿透是指缓存的数据库中都没有的数据，而用户不断发起请求，如发起id为‘-1’的数据或id为特别大不存在的数据，这是用户很可能是攻击者，攻击会导致数据库压力过大。
* 解决方案
  * 接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截。
  * 从缓存去不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户用统一个id暴力攻击

#### 5、缓存击穿

* 描述
  * 缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发按用户特别多，同时读缓存没读到数据，又同时区数据库去取数据，引起数据库压力瞬间增大，造成过大压力。

* 解决方案
  * 设置热点数据永远不过期
  * 加互斥锁

#### 6、缓存雪崩

* 描述
  * 缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至宕机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。

* 解决方案
  * 缓存数据的过期时间随机设置，防止同一时间大量数据过期现象发生
  * 如果缓存数据是分布式部署，将热点数据均匀分布在不同的缓存数据库中
  * 设置热点数据永不过期

#### 7、memcache与redis的区别都有哪些？

* 存储方式
  * memcache把数据全部存在内存中，断电后悔挂掉，数据不能超过内存大小
  * redis有部分存在硬盘上，redis可以持久化其数据

* 数据支持类型
  * memcache所有的值均是简单的字符串
  * redis支持更为丰富的数据类型，string，list，hash，set，zset

* value值大小不同
  * memcache只有1MB
  * redis最大可以达到1GB

* redis的速度比memcache快

#### 8、redis的过期策略

* 定期删除+惰性删除策略
* 为什么不使用定时删除呢？
  * 定时删除，用一个定时器来负责监视key，过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。

* 定期删除+惰性删除是如何工作的？
  * 定期删除，redis默认每隔100ms随机抽取进行检查，是否有过期的key，有过期key则删除。因为是随机抽取检查，所以只采用定期删除策略，会导致很对key到时间没有删除。这时，惰性删除就派上用场了，也就是当你在获取某个key的时候，redis会检查一下，这个key是否设置了过期时间，是否过期，如果过期了就会删除。

* 定期删除+惰性删除存在的问题？
  * 如果定期删除没有删除的key，然后也没有及时去请求key，也就是说惰性删除也没有生效，这样redis的内存会越来越高。

#### 9、redis内存淘汰策略

* **volatile-lru**：从已设置过期时间的数据集中挑选最近最少使用的数据，淘汰
* **volatile-ttl**：从已设置过期时间的数据集中挑选将要过期的数据淘汰
* **volatile-random**：从已设置过期时间的数据集中挑选任意数据淘汰
* **allkeys-lru**：从数据集中挑选最近最少使用的数据淘汰
* **allkeys-random**：从数据集中任意挑选数据淘汰
* **no-enviction（驱逐）**：禁止驱逐数据，新写入操作会报错
* **PS**：如果没有设置过期时间的数据，不满足先决条件；那么volatile-lru，volatile-ttl，volatile-random策略的行为，和no-enviction基本上一致。

#### 10、redis实现分布式锁

* redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对redis的链接并不存在竞争关系redis中可以使用SETNX命令实现分布式锁。
* 将key的值设置为value（value可以是任意值+int值（该int值表示加锁次数）），当且仅当key不存在。若给定的key已经存在，则SETNX不做任何动作
* 解锁
  * 使用del key命令就能释放锁

* 解决死锁
  * 通过redis中expire()给锁设定最大持有时间，如果超过，则redis来帮我们释放锁。
  * 使用setnx key “当前系统时间+锁持有的时间” 和getset key “当前系统时间 + 锁持有时间” 组合命令就可以实现。
  
#### 11、[redisson分布式锁实现][https://blog.csdn.net/shuangyueliao/article/details/89344256]

