#### 1、从输入URL到页面加载发生了什么？

* DNS解析
  * DNS解析的过程就是网址到ip地址的转换。
  * DNS解析时一个递归查询的过程
  * 首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。知道最后本地域名服务器得到google的IP地址并把它缓存到本地，供下一次查询使用。从上述过程中，可以看出网址的解析时一个从右向左的过程：com -> google.com -> www.google.com。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是www.google.com.，这里并不是多打了一个点，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.,既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所有网址真正的解析过程为：. -> .com -> google.com. -> www.google.com.。
  * DNS优化
    * 指DNS缓存，DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种：浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。
  * DNS负载均衡
    * CDN(Content Delivery Network)就是利用DNS的重定向技术（负载均衡），DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责相应用户的请求，提供所需的内容。
* TCP连接
  * HTTP协议是使用TCP作为其传输层协议的，当TCP出现瓶颈时，HTTP也会受到影响
  * HTTPS协议
    * HTTPS在传输数据之前需要客户端与服务器进行一个握手（TLS/SSL握手），在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL使用了非对称加密，对称加密以及hash等。
* 发送HTTP请求
* 服务器处理请求并返回HTTP报文
* 浏览器解析渲染页面
* 连接结束

#### 2、OSI七层模型都是什么？

* 应用层
* 表示层
* 回话层
* 传输层
* 网络层
* 数据链路层
* 物理层

#### 3、TCP和UDP的区别

* TCP是面向连接的，而UDP是不面向连接的。
* TCP的信息传输是可靠的，而UDP的信息传输是不可靠的

#### 4、TCP是如何实现可靠连接的？

* TCP协议主要通过校验和、序列号、确认应答（ACK）、重发控制、连接管路、窗口控制等实现可靠性连接。

#### 5、什么是MSL？

* MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

#### 6、为什么要进入TIME_WAIT状态？

* 保证这次连接的重复数据段从网络中消失
* 可靠地实现TCP全双工连接的终止

#### 7、为什么要等2MSL?1MSL不行么？

* 2MSL可以保证消息数据不丢失，1MSL存在丢失数据风险

#### 8、请列举出JDK中常用的设计模式？

* 观察者模式

* 桥接模式

  - ```java
    Set<String> names = Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>())
    ```

* 装饰者模式

  * ```java
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in))
    while(true){
        System.out.println(br.readLine())
    }
    ```

  * 

* builder建造者模式

* 工厂方法模式

* 适配器模式

#### 9、什么是设计模式？

* 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人里面、报账代码的可靠性。

#### 10、Java中什么叫单例设计模式？请用java写出线程安全的单例模式？

* 保证类的对象在内存中唯一。

* ```java
  class Single{
      private static volatile Single single;
      private Single(){
          
      }
      
      public static Single getInstance(){
          if(single == null){
              synchronized(Single.class){
                  if(single == null){
                      single = new Single();
                  }
              }
          }
          return single;
      }
  }
  ```

* 

#### 11、举例说明什么情况下会更倾向于使用抽象类而不是接口？

* 子类不需要单独实现的一些公共的功能时，可以放到抽象类中实现。例如模板模式









































#### 2、Hash碰撞性能分析

* Java7：随着HashMap的大小的增长，get()方法的开销也越来越大。由于所有的记录都在同一个桶里的超长链表内，平均查询一条记录就需要遍历一半的列表。
* Java8对此进行了优化，它是一个log的曲线，因此它的性能要好上好几个数量级。尽管有严重的哈希碰撞，已是最坏的情况了，但这个通盈的基准测试在JDK8中的实际复杂度是O(logn),单独来看JDK8的曲线的话会更清楚，是一个对数线性分布

#### 3、JDK8中hashMap为什么不用二叉查询树而选择红黑树？为什么不一直用红黑树？

* 之所以选择红黑树是为了解决二叉查询书的缺陷，二叉查找树在特殊情况下会变成一条线性结构（就跟原来的链表结构相同，造成很深的问题），遍历查找会非常慢。而红黑树在插入新数据后可能需要通过左旋、右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题。